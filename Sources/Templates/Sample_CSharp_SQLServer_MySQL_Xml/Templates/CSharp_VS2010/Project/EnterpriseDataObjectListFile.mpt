<CONFIG>
	NAME EnterpriseDataObjectListFile
	CATEGORY MiddleTier
	NODE Project
	TOPLEVEL False
</CONFIG>
<CONTENT>
<%%=USETABS false%%>
<%%-/*<copyright>
%%>
<%%=Solution.Copyright%%><%%-
</copyright>*/
using System;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Xml;
using System.Xml.Serialization;
using System.Runtime.Serialization;
using System.Text;
using System.IO;
using System.Collections.ObjectModel;
using System.Reflection;

namespace %%><%%=Namespace%%><%%-
{
	///--------------------------------------------------------------------------------
	/// <summary>This class is used for strongly typed sortable lists of enterprise
	/// objects (such as data access or business objects).</summary>
	///
	/// This library code was generated from a template.  Change the
	/// Status value below to something other than Generated if you have
	/// customized this file to prevent changes from being overwritten.
	///
	/// <CreatedByUserName>%%><%%=USER%%><%%-</CreatedByUserName>
	/// <CreatedDate>%%><%%=NOW%%><%%-</CreatedDate>
	/// <Status>Generated</Status>
	///--------------------------------------------------------------------------------
	[Serializable()]
	[CollectionDataContract]
	public class EnterpriseDataObjectList<T> : Collection<T>, IEnterpriseDataObjectList<T>, IEnterpriseEnumerable
		where T : IEnterpriseDataObject, new()
	{
		#region "Fields and Properties"
		///--------------------------------------------------------------------------------
		/// <summary>This property gets/sets whether an item has been added to the list.</summary>
		///--------------------------------------------------------------------------------
		[XmlIgnore]
		[IgnoreDataMember]
		public virtual bool IsItemAdded { get; set; }

		///--------------------------------------------------------------------------------
		/// <summary>This property gets/sets whether an item has been removed from the list.</summary>
		///--------------------------------------------------------------------------------
		[XmlIgnore]
		[IgnoreDataMember]
		public virtual bool IsItemRemoved { get; set; }

		///--------------------------------------------------------------------------------
		/// <summary>This get property determines if the data has been modified since the
		/// last load from a resource such as a database.</summary>
		///--------------------------------------------------------------------------------
		[XmlIgnore]
		[IgnoreDataMember]
		public virtual bool IsModified
		{
			get
			{
				if (IsItemAdded == true || IsItemRemoved == true)
				{
					return true;
				}
				foreach (T loopEnterpriseDataObject in this)
				{
					if (loopEnterpriseDataObject.IsModified == true)
					{
						return true;
					}
				}
				return false;
			}
		}

		///--------------------------------------------------------------------------------
		/// <summary>This get property determines if the data has all been loaded from a
		/// resource such as a database.</summary>
		///--------------------------------------------------------------------------------
		[XmlIgnore]
		[IgnoreDataMember]
		public virtual bool IsLoaded
		{
			get
			{
				foreach (T loopEnterpriseDataObject in this)
				{
					if (loopEnterpriseDataObject.IsLoaded == false)
					{
						return false;
					}
				}
				return true;
			}
		}

		///--------------------------------------------------------------------------------
		/// <summary>This property gets the representation of the instance as xml.</summary>
		///--------------------------------------------------------------------------------
		[XmlIgnore]
		[IgnoreDataMember]
		public string XmlData
		{
			get
			{
				return XmlHelper.Serialize(this);
			}
		}

		#endregion "Fields and Properties"

		#region "Methods"
		///--------------------------------------------------------------------------------
		/// <summary>This method finds an item by property and value.</summary>
		/// 
		///	<param name="propertyName">The name of a valid property in the sortable object.</param>
		///	<param name="propertyValue">The property value.</param>
		/// 
		/// <returns>A T of an item found.</returns>
		///--------------------------------------------------------------------------------
		public virtual IEnterpriseDataObject FindItem(string propertyName, object propertyValue)
		{
			// if the list is not empty and the property is valid, find an item
			if (this.Count > 0 && this[0].GetType().GetProperty(propertyName) != null)
			{
				return (Items as List<T>).Find(item => item.IsPropertyValueMatch(propertyName, propertyValue));
			}
			return default(T);
		}

		///--------------------------------------------------------------------------------
		/// <summary>This method finds an item by its ID value.</summary>
		/// 
		///	<param name="propertyValue">The ID value.</param>
		/// 
		/// <returns>A T of an item found.</returns>
		///--------------------------------------------------------------------------------
		public virtual IEnterpriseDataObject FindItemByID(Guid propertyValue)
		{
			// if the list is not empty, find an item
			if (this.Count > 0)
			{
				return (Items as List<T>).Find(item => item.ID == propertyValue);
			}
			return default(T);
		}

		///--------------------------------------------------------------------------------
		/// <summary>This method finds all items by property and value.</summary>
		/// 
		///	<param name="propertyName">The name of a valid property in the sortable object.</param>
		///	<param name="propertyValue">The property value.</param>
		/// 
		/// <returns>A list of items found.</returns>
		///--------------------------------------------------------------------------------
		public virtual IEnterpriseEnumerable FindItems(string propertyName, object propertyValue)
		{
			// if the list is not empty and the property is valid, find an item
			if (this.Count > 0 && this[0].GetType().GetProperty(propertyName) != null)
			{
				return new EnterpriseDataObjectList<T>((Items as List<T>).FindAll(item => item.IsPropertyValueMatch(propertyName, propertyValue)));
			}
			return null;
		}

		///--------------------------------------------------------------------------------
		/// <summary>This method resets the IsLoaded state for the instance.</summary>
		///
		/// <remarks>This should only be used if special business rules override normal loading behavior.</remarks>
		/// 
		/// <param name="isLoaded">The reset value for the IsLoaded property.</param>
		///--------------------------------------------------------------------------------
		public virtual void ResetLoaded(bool isLoaded)
		{
			foreach (T loopEnterpriseDataObject in this)
			{
				loopEnterpriseDataObject.ResetLoaded(isLoaded);
			}
		}

		///--------------------------------------------------------------------------------
		/// <summary>This method resets the IsModified state for the instance.</summary>
		///
		/// <remarks>This should only be used if special business rules override normal modified behavior.</remarks>
		/// 
		/// <param name="isModified">The reset value for the IsModified property.</param>
		///--------------------------------------------------------------------------------
		public virtual void ResetModified(bool isModified)
		{
			IsItemAdded = false;
			IsItemRemoved = false;
			foreach (T loopEnterpriseDataObject in this)
			{
				loopEnterpriseDataObject.ResetModified(isModified);
			}
		}

		///--------------------------------------------------------------------------------
		/// <summary>This method loads the data for this entity from an xml file.</summary>
		/// 
		/// <param name="inputFilePath">The path of the file to load from.</param>
		///--------------------------------------------------------------------------------
		public virtual void Load(string inputFilePath)
		{
			this.RemoveRange(0, this.Count);
			if (File.Exists(inputFilePath))
			{
				foreach (T loopItem in (IEnterpriseDataObjectList<T>)XmlHelper.Deserialize(FileHelper.GetText(inputFilePath), GetType()))
				{
					Add(loopItem);
				}
			}
		}

		///--------------------------------------------------------------------------------
		/// <summary>This method loads the data for this entity from an xml file.</summary>
		/// 
		/// <param name="inputText">The text to load from.</param>
		///--------------------------------------------------------------------------------
		public virtual void LoadFromText(string inputText)
		{
			this.RemoveRange(0, this.Count);
			foreach (T loopItem in (IEnterpriseDataObjectList<T>)XmlHelper.Deserialize(inputText, GetType()))
			{
				Add(loopItem);
			}
		}

		///--------------------------------------------------------------------------------
		/// <summary>This method saves the data for this entity as an xml file.</summary>
		/// 
		/// <param name="inputFilePath">The path of the file to save to.</param>
		///--------------------------------------------------------------------------------
		public virtual void Save(string inputFilePath)
		{
			FileHelper.AppendToFile(inputFilePath, XmlHelper.Serialize(this));
		}

		///--------------------------------------------------------------------------------
		/// <summary>This method adds a tracked item to the list.  The list will indicate
		/// that an item has been added to the list.</summary>
		/// 
		/// <param name="item">The item to be added.</param>
		///--------------------------------------------------------------------------------
		public virtual void AddTrackedItem(T item)
		{
			IsItemAdded = true;
			Add(item);
		}

		///--------------------------------------------------------------------------------
		/// <summary>This method inserts a tracked item to the list at the specified index.
		/// The list will indicate that an item has been added to the list.</summary>
		/// 
		/// <param name="index">The index in the list to insert into.</param>
		/// <param name="item">The item to be added.</param>
		///--------------------------------------------------------------------------------
		public virtual void InsertTrackedItem(int index, T item)
		{
			IsItemAdded = true;
			Insert(index, item);
		}

		///--------------------------------------------------------------------------------
		/// <summary>This method removes a tracked item from the list.  The list will indicate
		/// that an item has been added to the list.</summary>
		/// 
		/// <param name="item">The item to be added.</param>
		///--------------------------------------------------------------------------------
		public virtual void RemoveTrackedItem(T item)
		{
			IsItemAdded = true;
			Remove(item);
		}

		///--------------------------------------------------------------------------------
		/// <summary>This method compares two items by the input property and sort direction.</summary>
		/// 
		///	<param name="item1">The first (left) item to compare.</param>
		///	<param name="item2">The second (right) item to compare.</param>
		///	<param name="propertyName">The name of a valid property in the sortable object.</param>
		///	<param name="isRandomSort">Flag, indicating whether sort is a random sort.</param>
		/// 
		/// <returns>The result of the compare.</returns>
		///--------------------------------------------------------------------------------
		public virtual int ItemCompare(T item1, T item2, string propertyName, bool isRandomSort)
		{
			// get the values
			string item1Value = item1.GetPropertyValueString(propertyName);
			string item2Value = item2.GetPropertyValueString(propertyName);
			string systemType = this[0].GetPropertyInfo(propertyName).PropertyType.UnderlyingSystemType.Name;

			// return a comparison based on either or both items being null
			if (item1Value == null && item2Value == null)
			{
				return 0;
			}
			else if (item1Value == null)
			{
				return -1;
			}
			else if (item2Value == null)
			{
				return 1;
			}

			if (isRandomSort == true)
			{
				// perform random compare
				return item1.RandomInt.CompareTo(item2.RandomInt);
			}

			// perform data compare
			switch (systemType)
			{
				// handle compare of numeric types
				case "SByte":
				case "Int16":
				case "Int32":
				case "Int64":
					return item1Value.GetLong().CompareTo(item2Value.GetLong());
				case "Byte":
				case "UInt16":
				case "UInt32":
				case "UInt64":
					return item1Value.GetULong().CompareTo(item2Value.GetULong());
				case "Single":
				case "Double":
					return item1Value.GetDouble().CompareTo(item2Value.GetDouble());
				case "Decimal":
					return item1Value.GetDecimal().CompareTo(item2Value.GetDecimal());
				default:
					break;
			}

			// by default, do string compare
			return item1Value.CompareTo(item2Value);
		}

		///--------------------------------------------------------------------------------
		/// <summary>This method sets the RandomInt property for each item in the collection,
		/// as an aid for random sorting.</summary>
		///--------------------------------------------------------------------------------
		public virtual void SetRandomInts()
		{
			foreach (T item in this)
			{
				item.RandomInt = DataHelper.GetRandomInt();
			}
		}

		///--------------------------------------------------------------------------------
		/// <summary>This method sorts the list by the input property and sort direction.</summary>
		/// 
		///	<param name="propertyName">The name of a valid property in the sortable object.</param>
		///	<param name="sortDirection">The direction of the sort: ascending, descending, or random.</param>
		///--------------------------------------------------------------------------------
		public virtual void Sort(string propertyName, ListSortDirection sortDirection)
		{
			// if the list is not empty and the property is valid, sort the list
			if (this.Count > 0 && this[0].GetPropertyInfo(propertyName) != null)
			{
				switch (sortDirection)
				{
					case ListSortDirection.Ascending:
						// ascending sort
						(Items as List<T>).Sort((i1, i2) => ItemCompare(i1, i2, propertyName, false));
						break;
					case ListSortDirection.Descending:
						// descending sort
                        (Items as List<T>).Sort((i1, i2) => ItemCompare(i2, i1, propertyName, false));
						break;
					default:
						// random sort
						SetRandomInts();
                        (Items as List<T>).Sort((i1, i2) => ItemCompare(i2, i1, propertyName, true));
						break;
				}
			}
		}

		///--------------------------------------------------------------------------------
		/// <summary>This method sorts the list by two input properties and sort directions.</summary>
		/// 
		///	<param name="propertyName1">The name of a primary valid property in the sortable object.</param>
		///	<param name="sortDirection1">The direction of the primary sort: ascending, descending, or random.</param>
		///	<param name="propertyName2">The name of a valid secondary property in the sortable object.</param>
		///	<param name="sortDirection2">The direction of the secondary sort: ascending, descending, or random.</param>
		///--------------------------------------------------------------------------------
		public virtual void Sort(string propertyName1, ListSortDirection sortDirection1, string propertyName2, ListSortDirection sortDirection2)
		{
			// if the list is not empty and the property is valid, sort the list
			if (this.Count > 0 && this[0].GetPropertyInfo(propertyName1) != null && this[0].GetPropertyInfo(propertyName2) != null)
			{
				if (sortDirection1 == ListSortDirection.Ascending)
				{
					switch (sortDirection2)
					{
						case ListSortDirection.Ascending:
							// ascending primary and secondary sort
                            (Items as List<T>).Sort((i1, i2) => ItemCompare(i1, i2, propertyName1, false) == 0 ? ItemCompare(i1, i2, propertyName2, false) : ItemCompare(i1, i2, propertyName1, false));
							break;
						case ListSortDirection.Descending:
							// ascending primary and descending secondary sort
                            (Items as List<T>).Sort((i1, i2) => ItemCompare(i1, i2, propertyName1, false) == 0 ? ItemCompare(i2, i1, propertyName2, false) : ItemCompare(i1, i2, propertyName1, false));
							break;
						default:
							// ascending primary and random secondary sort
							SetRandomInts();
                            (Items as List<T>).Sort((i1, i2) => ItemCompare(i1, i2, propertyName1, false) == 0 ? ItemCompare(i1, i2, propertyName2, true) : ItemCompare(i1, i2, propertyName1, false));
							break;
					}
				}
				else if (sortDirection1 == ListSortDirection.Descending)
				{
					switch (sortDirection2)
					{
						case ListSortDirection.Ascending:
							// descending primary and ascending secondary sort
                            (Items as List<T>).Sort((i1, i2) => ItemCompare(i2, i1, propertyName1, false) == 0 ? ItemCompare(i1, i2, propertyName2, false) : ItemCompare(i2, i1, propertyName1, false));
							break;
						case ListSortDirection.Descending:
							// descending primary and secondary sort
                            (Items as List<T>).Sort((i1, i2) => ItemCompare(i2, i1, propertyName1, false) == 0 ? ItemCompare(i2, i1, propertyName2, false) : ItemCompare(i2, i1, propertyName1, false));
							break;
						default:
							// descending primary and random secondary sort
							SetRandomInts();
                            (Items as List<T>).Sort((i1, i2) => ItemCompare(i2, i1, propertyName1, false) == 0 ? ItemCompare(i1, i2, propertyName2, true) : ItemCompare(i2, i1, propertyName1, false));
							break;
					}
				}
				else
				{
					// random sort (don't bother sorting second column)
					SetRandomInts();
					(Items as List<T>).Sort((i1, i2) => ItemCompare(i1, i2, propertyName1, true));
				}
			}
		}


		///--------------------------------------------------------------------------------
		/// <summary>This method sorts the list by the input lamda expression and direction.</summary>
		/// 
		///	<param name="sortProperty">The lamda expression to indicate which property to sort by.</param>
		///	<param name="sortDirection">The direction of the sort: ascending, descending, or random.</param>
		///--------------------------------------------------------------------------------
		public void Sort<TKey>(Func<T, TKey> sortProperty, ListSortDirection sortDirection)
		{
			switch (sortDirection)
			{
				case ListSortDirection.Ascending:
					ApplySort(Items.OrderBy(sortProperty));
					break;
				case ListSortDirection.Descending:
					ApplySort(Items.OrderByDescending(sortProperty));
					break;
				default:
					// ignore sort property, just do random sort
					ApplySort(Items.OrderBy(i => i.RandomInt));
					break;
			}
		}

		///--------------------------------------------------------------------------------
		/// <summary>This method sorts the list by the input lamda expression and comparer.</summary>
		/// 
		///	<param name="sortProperty">The lamda expression to indicate which property to sort by.</param>
		///	<param name="comparer">The comparer for the sort.</param>
		///--------------------------------------------------------------------------------
		public void Sort<TKey>(Func<T, TKey> sortProperty, IComparer<TKey> comparer)
		{
			ApplySort(Items.OrderBy(sortProperty, comparer));
		}

		///--------------------------------------------------------------------------------
		/// <summary>This method sorts the list by input sorted order.</summary>
		/// 
		///	<param name="sortedItems">The desired order of the items.</param>
		///--------------------------------------------------------------------------------
		private void ApplySort(IEnumerable<T> sortedItems)
		{
			var items = sortedItems.ToList();

			Items.Clear();
			foreach (var item in items)
			{
				Items.Add(item);
			}
		}

		///--------------------------------------------------------------------------------
		/// <summary>This method finds an item by property and value.</summary>
		/// 
		///	<param name="propertyName">The name of a valid property in the sortable object.</param>
		///	<param name="propertyValue">The direction of the sort: ascending, descending, or random.</param>
		/// 
		/// <returns>A T of an item found.</returns>
		///--------------------------------------------------------------------------------
		public virtual T Find(string propertyName, object propertyValue)
		{
			// if the list is not empty and the property is valid, find an item
			if (this.Count > 0 && this[0].GetPropertyInfo(propertyName) != null)
			{
                return (Items as List<T>).Find(item => item.IsPropertyValueMatch(propertyName, propertyValue));
			}
			return default(T);
		}

		///--------------------------------------------------------------------------------
		/// <summary>This method finds an item by its ID value.</summary>
		/// 
		///	<param name="propertyValue">The ID value.</param>
		/// 
		/// <returns>A T of an item found.</returns>
		///--------------------------------------------------------------------------------
		public virtual T FindByID(Guid propertyValue)
		{
			// if the list is not empty, find an item
			if (this.Count > 0)
			{
				return (Items as List<T>).Find(item => item.ID == propertyValue);
			}
			return default(T);
		}

		///--------------------------------------------------------------------------------
		/// <summary>This method finds an item by two properties and values.</summary>
		/// 
		///	<param name="propertyName1">The name of a valid primary property in the sortable object.</param>
		///	<param name="propertyValue1">The value for the primary property.</param>
		///	<param name="propertyName2">The name of a valid secondary property in the sortable object.</param>
		///	<param name="propertyValue2">The value for the secondary property.</param>
		/// 
		/// <returns>A T of an item found.</returns>
		///--------------------------------------------------------------------------------
		public virtual T Find(string propertyName1, object propertyValue1, string propertyName2, object propertyValue2)
		{
			// if the list is not empty and the property is valid, find an item
			if (this.Count > 0 && this[0].GetPropertyInfo(propertyName1) != null && this[0].GetPropertyInfo(propertyName2) != null)
			{
                return (Items as List<T>).Find(item => item.IsPropertyValueMatch(propertyName1, propertyValue1) && item.IsPropertyValueMatch(propertyName2, propertyValue2));
			}
			return default(T);
		}

		///--------------------------------------------------------------------------------
		/// <summary>This method finds an item by lamda expression.</summary>
		/// 
		///	<param name="predicate">The lamda expression for the find.</param>
		/// 
		/// <returns>A T of an item found.</returns>
		///--------------------------------------------------------------------------------
		public virtual T Find(System.Predicate<T> predicate)
		{
			// if the list is not empty and the property is valid, find an item
			if (this.Count > 0)
			{
				return (Items as List<T>).Find(predicate);
			}
			return default(T);
		}

		///--------------------------------------------------------------------------------
		/// <summary>This method finds all items by property and value.</summary>
		/// 
		///	<param name="propertyName">The name of a valid property in the sortable object.</param>
		///	<param name="propertyValue">The direction of the sort: ascending, descending, or random.</param>
		/// 
		/// <returns>A List of all items found.</returns>
		///--------------------------------------------------------------------------------
		public virtual List<T> FindAll(string propertyName, object propertyValue)
		{
			// if the list is not empty and the property is valid, find an item
			if (this.Count > 0 && this[0].GetPropertyInfo(propertyName) != null)
			{
                return (Items as List<T>).FindAll(item => item.IsPropertyValueMatch(propertyName, propertyValue));
			}
			return null;
		}

		///--------------------------------------------------------------------------------
		/// <summary>This method finds all items by two properties and values.</summary>
		/// 
		///	<param name="propertyName1">The name of a valid primary property in the sortable object.</param>
		///	<param name="propertyValue1">The value for the primary property.</param>
		///	<param name="propertyName2">The name of a valid secondary property in the sortable object.</param>
		///	<param name="propertyValue2">The value for the secondary property.</param>
		/// 
		/// <returns>A List of all items found.</returns>
		///--------------------------------------------------------------------------------
		public virtual List<T> FindAll(string propertyName1, object propertyValue1, string propertyName2, object propertyValue2)
		{
			// if the list is not empty and the property is valid, find an item
			if (this.Count > 0 && this[0].GetPropertyInfo(propertyName1) != null && this[0].GetPropertyInfo(propertyName2) != null)
			{
                return (Items as List<T>).FindAll(item => item.IsPropertyValueMatch(propertyName1, propertyValue1) && item.IsPropertyValueMatch(propertyName2, propertyValue2));
			}
			return null;
		}

		///--------------------------------------------------------------------------------
		/// <summary>This method finds all items by lamda expression.</summary>
		/// 
		///	<param name="predicate">The lamda expression for the find.</param>
		/// 
		/// <returns>A T of an item found.</returns>
		///--------------------------------------------------------------------------------
		public virtual List<T> FindAll(System.Predicate<T> predicate)
		{
			// if the list is not empty and the property is valid, find an item
			if (this.Count > 0)
			{
				return (Items as List<T>).FindAll(predicate);
			}
			return null;
		}

		///--------------------------------------------------------------------------------
        /// <summary>This method removes a range of items from the list.</summary>
        /// 
        ///	<param name="index">The beginning position for items to remove.</param>
        ///	<param name="count">The number of items to remove.</param>
        ///--------------------------------------------------------------------------------
        public virtual void RemoveRange(int index, int count)
        {
            (Items as List<T>).RemoveRange(index, count);
        }

		///--------------------------------------------------------------------------------
		/// <summary>This method build a page of items in the overall list.  The items in the
		/// list are references to the items in the overall list.</summary>
		/// 
		///	<param name="pageSize">The size of the page to return.</param>
		///	<param name="pageIndex">The index of the page into the overall list.</param>
		/// 
		/// <returns>A EnterpriseDataObjectList containing a reference page of the original list.</returns>
		///--------------------------------------------------------------------------------
		public virtual EnterpriseDataObjectList<T> ReferencePage(int pageSize, int pageIndex)
		{
			EnterpriseDataObjectList<T> listPage = new EnterpriseDataObjectList<T>();

			// if the list is not empty and the property is valid, find an item
			if ((pageSize > 0) && (pageSize < this.Count))
			{
				for (int i = pageIndex; i < this.Count; i++)
				{
					if (listPage.Count >= pageSize)
					{
						break;
					}
					listPage.Add(this[i]);
				}
			}
			return listPage;
		}

		///--------------------------------------------------------------------------------
		/// <summary>This method returns whether an item is found in the list, with a corresponding
		/// property value.</summary>
		/// 
		///	<param name="item">The item to look for a match in the list.</param>
		///	<param name="propertyName">The name of a valid property in the sortable object.</param>
		/// 
		/// <returns>True if item found, false otherwise.</returns>
		///--------------------------------------------------------------------------------
		public virtual bool Contains(T item, string propertyName)
		{
			// if the list is not empty and the property is valid, see if item is in list by matching property value
			if (this.Count > 0 && item.GetPropertyInfo(propertyName) != null)
			{
                return (Items as List<T>).Find(item2 => item2.IsPropertyValueMatch(propertyName, item.GetPropertyValueString(propertyName))) != null;
			}
			return false;
		}

		///--------------------------------------------------------------------------------
		/// <summary>This method returns whether an item is found in the list, with corresponding
		/// two property values.</summary>
		/// 
		///	<param name="item">The item to look for a match in the list.</param>
		///	<param name="propertyName1">The name of a valid primary property in the sortable object.</param>
		///	<param name="propertyName2">The name of a valid secondary property in the sortable object.</param>
		/// 
		/// <returns>True if item found, false otherwise.</returns>
		///--------------------------------------------------------------------------------
		public virtual bool Contains(T item, string propertyName1, string propertyName2)
		{
			// if the list is not empty and the property is valid, see if item is in list by matching property value
			if (this.Count > 0 && item.GetPropertyInfo(propertyName1) != null && item.GetPropertyInfo(propertyName2) != null)
			{
                return (Items as List<T>).Find(item2 => (item2.IsPropertyValueMatch(propertyName1, item.GetPropertyValueString(propertyName1)) && item2.IsPropertyValueMatch(propertyName2, item.GetPropertyValueString(propertyName2)))) != null;
			}
			return false;
		}

		///--------------------------------------------------------------------------------
		/// <summary>This delegate is to be used for the comparison of two items, primarily
		/// for lamda expressions.</summary>
		///--------------------------------------------------------------------------------
		public delegate int Comparison<TItem>(TItem item1, TItem item2);

		///--------------------------------------------------------------------------------
		/// <summary>This delegate is to be used for qualifying an item, primarily for lamda
		/// expressions.</summary>
		///--------------------------------------------------------------------------------
		public delegate int Predicate<TItem>(TItem item);

		///--------------------------------------------------------------------------------
		/// <summary>This method retrieves tab delimited data of all serializable public
		/// property elements (non complex or array types).  Header is included.</summary>
		/// 
		/// <returns>Tab delimited data of the list, with a header.</returns>
		///--------------------------------------------------------------------------------
		public string GetDelimitedData()
		{
			return GetDelimitedData(true, true, "\t");
		}

		///--------------------------------------------------------------------------------
		/// <summary>This method retrieves tab delimited data of all serializable public
		/// property elements (non complex or array types).  Header is included if specified.</summary>
		/// 
		/// <param name="includeHeader">Specifies whether or not to include the header in
		/// the output.</param>
		/// 
		/// <returns>Tab delimited data of the list, with a header if specified by the user.</returns>
		///--------------------------------------------------------------------------------
		public string GetDelimitedData(bool includeHeader)
		{
			return GetDelimitedData(includeHeader, true, "\t");
		}

		///--------------------------------------------------------------------------------
		/// <summary>This method retrieves tab delimited data of all serializable public
		/// property elements (non complex or array types).  Header is included if specified.</summary>
		/// 
		/// <param name="includeHeader">Specifies whether or not to include the header in
		/// the output.</param>
		/// <param name="includeData">Specifies whether or not to include the data in
		/// the output.</param>
		/// <param name="delimiter">The user specified delimiter.</param>
		/// 
		/// <returns>Delimited data of the list, with delimiter and header specified by user.</returns>
		///--------------------------------------------------------------------------------
		public string GetDelimitedData(bool includeHeader, bool includeData, string delimiter)
		{
			StringBuilder output = new StringBuilder();

			if (Count > 0)
			{
				if (includeHeader == true)
				{
					output.Append(this[0].GetDelimitedData(true, false, delimiter));
				}
				if (includeData == true)
				{
					foreach (T loopItem in this)
					{
						output.Append(loopItem.GetDelimitedData(false, true, delimiter));
					}
				}
			}
			return output.ToString();
		}

		///--------------------------------------------------------------------------------
		/// <summary>This method retrieves formatted data of all serializable public
		/// property elements (non complex or array types).  Header is included, 80 character
		/// maximum per column.</summary>
		/// 
		/// <returns>Formatted data of the list, with a header.</returns>
		///--------------------------------------------------------------------------------
		public string GetFormattedData()
		{
			return GetFormattedData(true, true, 80);
		}

		///--------------------------------------------------------------------------------
		/// <summary>This method retrieves formatted data of all serializable public
		/// property elements (non complex or array types).  Header is included, 80 character
		/// maximum per column.</summary>
		/// 
		/// <param name="includeHeader">Specifies whether or not to include the header in
		/// the output.</param>
		/// 
		/// <returns>Formatted data of the list, with a header if specified by the user.</returns>
		///--------------------------------------------------------------------------------
		public string GetFormattedData(bool includeHeader)
		{
			return GetFormattedData(includeHeader, true, 80);
		}

		///--------------------------------------------------------------------------------
		/// <summary>This method retrieves formatted data of all serializable public
		/// property elements (non complex or array types).  Header and maximum characters
		/// per column is input.</summary>
		/// 
		/// <param name="includeHeader">Specifies whether or not to include the header in
		/// the output.</param>
		/// <param name="includeData">Specifies whether or not to include the data in
		/// the output.</param>
		/// <param name="maxWidthPerColumn">The maximum number of characters per column.</param>
		/// 
		/// <remarks>In this version, the output only looks good for fixed width character
		/// fonts such as courier.</remarks>
		/// 
		/// <returns>Formatted data of the list, with options as specified by the user.</returns>
		///--------------------------------------------------------------------------------
		public string GetFormattedData(bool includeHeader, bool includeData, int maxWidthPerColumn)
		{
			StringBuilder output = new StringBuilder();
			NameObjectCollection outputCollection = new NameObjectCollection();
			NameObjectCollection maxColumnWidths = new NameObjectCollection();

			if (Count > 0)
			{
				int row = 0;
				if (includeHeader == true)
				{
					// add titles into collection
					foreach (PropertyInfo loopInfo in this[0].GetType().GetProperties())
					{
						string title = loopInfo.Name;
						if (title.Length > maxWidthPerColumn)
						{
							title = title.Substring(0, maxWidthPerColumn);
						}
						if (loopInfo.GetCustomAttributes(typeof(XmlElementAttribute), true).Length > 0)
						{
							outputCollection["title, " + loopInfo.Name] = title;
							maxColumnWidths[loopInfo.Name] = Math.Min(title.Length, maxWidthPerColumn);
						}
					}
				}
				if (includeData == true)
				{
					// add data into collection
					row = 0;
					foreach (T item in this)
					{
						foreach (PropertyInfo loopInfo in item.GetType().GetProperties())
						{
							string value = item.GetPropertyValueString(loopInfo.Name).GetString();
							if (value.Length > maxWidthPerColumn)
							{
								value = value.Substring(0, maxWidthPerColumn);
							}
							if (loopInfo.GetCustomAttributes(typeof(XmlElementAttribute), true).Length > 0)
							{
								// output serializable element data into collection
								outputCollection[row.ToString() + ", " + loopInfo.Name] = value;
								maxColumnWidths[loopInfo.Name] = Math.Max((int)maxColumnWidths[loopInfo.Name], value.Length);
								maxColumnWidths[loopInfo.Name] = Math.Min((int)maxColumnWidths[loopInfo.Name], maxWidthPerColumn);
							}
						}
						row++;
					}
				}

				if (includeHeader == true)
				{
					// add padded titles to output
					foreach (PropertyInfo loopInfo in this[0].GetType().GetProperties())
					{
						if (loopInfo.GetCustomAttributes(typeof(XmlElementAttribute), true).Length > 0)
						{
							output.Append(DataHelper.PadStringToLength(outputCollection["title, " + loopInfo.Name].ToString(), (int)maxColumnWidths[loopInfo.Name], DataHelper.IsLeftJustifiedSystemType(loopInfo.PropertyType.UnderlyingSystemType.Name)));
							output.Append("  ");
						}
					}
				}
				if (includeData == true)
				{
					// add padded data to output
					row = 0;
					foreach (T item in this)
					{
						output.Append("\r\n");
						foreach (PropertyInfo loopInfo in item.GetType().GetProperties())
						{
							if (loopInfo.GetCustomAttributes(typeof(XmlElementAttribute), true).Length > 0)
							{
								output.Append(DataHelper.PadStringToLength(outputCollection[row.ToString() + ", " + loopInfo.Name].ToString(), (int)maxColumnWidths[loopInfo.Name], DataHelper.IsLeftJustifiedSystemType(loopInfo.PropertyType.UnderlyingSystemType.Name)));
								output.Append("  ");
							}
						}
						row++;
					}
				}
			}
			return output.ToString();
		}
	
		///--------------------------------------------------------------------------------
		/// <summary>This method takes in an enterprise data object list of an input type
		/// and transforms it to a list of the output type.</summary>
		/// 
		///	<param name="inputEnterpriseDataObjectList">The input list to transform to this list.</param>
		///	<param name="filterElements">Field and property values to exclude from transform.</param>
		/// 
		/// <returns>An enterprise data object list of type TOutput.</returns>
		///--------------------------------------------------------------------------------
		public static EnterpriseDataObjectList<T> CreateList<TInput>(EnterpriseDataObjectList<TInput> inputEnterpriseDataObjectList, NameObjectCollection filterElements)
			where TInput : IEnterpriseDataObject, new()
		{
			if (inputEnterpriseDataObjectList != null)
			{
				EnterpriseDataObjectList<T> outputEnterpriseDataObjectList = new EnterpriseDataObjectList<T>();
				foreach (TInput loopItem in inputEnterpriseDataObjectList)
				{
					T newItem = new T();
					newItem.TransformDataFromObject(loopItem, filterElements);
					outputEnterpriseDataObjectList.Add(newItem);
				}
				return outputEnterpriseDataObjectList;
			}
			return null;
		}

		#endregion "Methods"

		#region "Constructors"
		///--------------------------------------------------------------------------------
		/// <summary>This base constructor creates an empty list.</summary>
		///--------------------------------------------------------------------------------
		public EnterpriseDataObjectList()
		{
		}

		///--------------------------------------------------------------------------------
		/// <summary>This constructor takes in a list from which data is copied from.</summary>
		/// 
		///	<param name="sourceDataObjectList">The input List to transform to this list.</param>
		///	<param name="copyItems">Flag indicating whether items in the list should be copied (or retained).</param>
		///--------------------------------------------------------------------------------
		public EnterpriseDataObjectList(IEnumerable<T> sourceDataObjectList, bool copyItems = true)
		{
			if (sourceDataObjectList != null)
			{
				foreach (T loopItem in sourceDataObjectList)
				{
					if (copyItems == true)
					{
						T newItem = new T();
						newItem.TransformDataFromObject(loopItem, null);
						this.Add(newItem);
					}
					else
					{
						this.Add(loopItem);
					}
				}
			}
		}

		///--------------------------------------------------------------------------------
		/// <summary>This constructor takes in an enterprise data object list of the same
		/// type and transforms it to this list.</summary>
		/// 
		///	<param name="inputEnterpriseDataObjectList">The input list to transform to this list.</param>
		///	<param name="filterElements">Field and property values to exclude from transform.</param>
		///	<param name="copyItems">Flag indicating whether items in the list should be copied (or retained).</param>
		///--------------------------------------------------------------------------------
		public EnterpriseDataObjectList(EnterpriseDataObjectList<T> inputEnterpriseDataObjectList, NameObjectCollection filterElements, bool copyItems = true)
		{
			if (inputEnterpriseDataObjectList != null)
			{
				foreach (T loopItem in inputEnterpriseDataObjectList)
				{
					if (copyItems == true)
					{
						T newItem = new T();
						newItem.TransformDataFromObject(loopItem, filterElements);
						Add(newItem);
					}
					else
					{
						Add(loopItem);
					}
				}
			}
		}

		///--------------------------------------------------------------------------------
		/// <summary>This constructor takes in an enterprise (or sortable) data object list of another
		/// type (as an object) and transforms it to this list.</summary>
		/// 
		///	<param name="inputListItemType">The type for the items to be found in the input list.</param>
		///	<param name="inputEnterpriseDataObjectList">The input list (as an object) to transform to this list.</param>
		///	<param name="filterElements">Field and property values to exclude from transform.</param>
		///--------------------------------------------------------------------------------
		public EnterpriseDataObjectList(Type inputListItemType, object inputEnterpriseDataObjectList, NameObjectCollection filterElements)
		{
			if (inputEnterpriseDataObjectList != null)
			{
				if (inputEnterpriseDataObjectList.GetType().Name.Contains("EnterpriseDataObjectList") == true)
				{
					// handle enterprise data object list
					Type inputListType = typeof(EnterpriseDataObjectList<>);
					Type genericListType = inputListType.MakeGenericType(inputListItemType);
					IList items = (IList)Activator.CreateInstance(genericListType, inputEnterpriseDataObjectList, filterElements, true);
					foreach (IEnterpriseDataObject loopItem in items)
					{
						T newItem = new T();
						newItem.TransformDataFromObject(loopItem, filterElements);
						Add(newItem);
					}
				}
				else if (inputEnterpriseDataObjectList.GetType().Name.Contains("EnterpriseDataObjectList") == true)
				{
					// special handling of input sortable data object list
					Type inputListType = typeof(IEnterpriseDataObjectList<>);
					Type genericListType = inputListType.MakeGenericType(inputListItemType);
					IList items = (IList)Activator.CreateInstance(genericListType, inputEnterpriseDataObjectList, filterElements);
					foreach (IEnterpriseDataObject loopItem in items)
					{
						T newItem = new T();
						newItem.TransformDataFromObject(loopItem, filterElements);
						Add(newItem);
					}
				}
				else
				{
					// unsupported input list type
					throw new ApplicationException("EnterpriseDataObjectList constructor given input list of the wrong type: " + inputEnterpriseDataObjectList.GetType().Name);
				}
			}
		}

		///--------------------------------------------------------------------------------
		/// <summary>This constructor takes in a list from which data is copied from.</summary>
		/// 
		/// <param name="sourceDataObjectList">The source list to copy to this list.</param>
		///--------------------------------------------------------------------------------
		public EnterpriseDataObjectList(List<T> sourceDataObjectList)
		{
			if (sourceDataObjectList != null)
			{
				foreach (T loopItem in sourceDataObjectList)
				{
					T newItem = new T();
					newItem.TransformDataFromObject(loopItem, null);
					this.Add(newItem);
				}
			}
		}

		///--------------------------------------------------------------------------------
		/// <summary>This constructor takes in a sortable list from which data is copied from.</summary>
		/// 
		/// <param name="sourceDataObjectList">The source sortable list to copy to this list.</param>
		///--------------------------------------------------------------------------------
		public EnterpriseDataObjectList(IEnterpriseDataObjectList<T> sourceDataObjectList)
		{
			if (sourceDataObjectList != null)
			{
				foreach (T loopItem in sourceDataObjectList)
				{
					T newItem = new T();
					newItem.TransformDataFromObject(loopItem, null);
					this.Add(newItem);
				}
			}
		}

		///--------------------------------------------------------------------------------
		/// <summary>This constructor takes in a source list from which data is copied from.
		/// Output properties can be filtered out.</summary>
		/// 
		/// <param name="sourceDataObjectList">The source sortable list to copy to this list.</param>
		///	<param name="filterElements">Field and property values to exclude from transform.</param>
		///--------------------------------------------------------------------------------
		public EnterpriseDataObjectList(IEnterpriseDataObjectList<T> sourceDataObjectList, NameObjectCollection filterElements)
		{
			if (sourceDataObjectList != null)
			{
				foreach (T loopItem in sourceDataObjectList)
				{
					T newItem = new T();
					newItem.TransformDataFromObject(loopItem, filterElements);
					this.Add(newItem);
				}
			}
		}
		#endregion "Constructors"
	}
}
%%></CONTENT><OUTPUT>
<%%:
if (File(EnterpriseDataObjectListFilePath) == null || (File(EnterpriseDataObjectListFilePath).Contains("<Status>Generated</Status>") == true && File(EnterpriseDataObjectListFilePath).FilterIgnored().FilterProtected() != Text.FilterIgnored().FilterProtected()))
{
	update(EnterpriseDataObjectListFilePath)
}
%%></OUTPUT>